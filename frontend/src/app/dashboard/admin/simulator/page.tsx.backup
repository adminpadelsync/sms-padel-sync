'use client'

import { useState, useEffect } from 'react'
import { PlayerColumn } from './player-column'

interface Player {
    player_id: string
    name: string
    phone_number: string
    declared_skill_level: number
}

interface Message {
    id: string
    from: 'system' | 'player'
    text: string
    timestamp: Date
}

interface Match {
    id: string
    number: number
    time: string
    date: string
    court: string
    confirmedPlayerIds: string[]
}

export default function SMSSimulatorPage() {
    const [players, setPlayers] = useState<Player[]>([])
    const [selectedPlayers, setSelectedPlayers] = useState<Player[]>([])
    const [conversations, setConversations] = useState<Record<string, Message[]>>({})
    const [matches, setMatches] = useState<Match[]>([]) // All matches
    const [playerMatches, setPlayerMatches] = useState<Record<string, number[]>>({}) // player_id -> match numbers
    const [loading, setLoading] = useState(false)
    const [nextMatchNumber, setNextMatchNumber] = useState(1)

    // Fetch players on mount
    useEffect(() => {
        fetchPlayers()
    }, [])

    const fetchPlayers = async () => {
        try {
            const response = await fetch('/api/players')
            if (response.ok) {
                const data = await response.json()
                setPlayers(data.players || [])
            }
        } catch (error) {
            console.error('Error fetching players:', error)
        }
    }

    const handleSelectPlayer = (playerId: string) => {
        const player = players.find(p => p.player_id === playerId)
        if (player && selectedPlayers.length < 6 && !selectedPlayers.find(p => p.player_id === playerId)) {
            setSelectedPlayers([...selectedPlayers, player])
            setConversations({
                ...conversations,
                [player.player_id]: []
            })
        }
    }

    const handleRemovePlayer = (playerId: string) => {
        setSelectedPlayers(selectedPlayers.filter(p => p.player_id !== playerId))
        const newConversations = { ...conversations }
        delete newConversations[playerId]
        setConversations(newConversations)
    }

    const handleSendMatchInvite = async () => {
        if (selectedPlayers.length < 4) {
            alert('Please select at least 4 players')
            return
        }

        setLoading(true)
        try {
            // Get tomorrow's date
            const tomorrow = new Date()
            tomorrow.setDate(tomorrow.getDate() + 1)
            const dateStr = tomorrow.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })

            // Simulate sending match invite
            const inviteMessage = `ðŸŽ¾ Padel match invite! Would you like to play tomorrow (${dateStr}) at 3:00 PM? Reply YES or NO.`

            const newConversations = { ...conversations }
            selectedPlayers.forEach(player => {
                const message: Message = {
                    id: Date.now().toString() + player.player_id,
                    from: 'system',
                    text: inviteMessage,
                    timestamp: new Date()
                }
                newConversations[player.player_id] = [
                    ...(newConversations[player.player_id] || []),
                    message
                ]
            })
            setConversations(newConversations)
        } catch (error) {
            console.error('Error sending invites:', error)
            alert('Failed to send invites')
        } finally {
            setLoading(false)
        }
    }

    const handlePlayerMessage = (playerId: string, messageText: string) => {
        const message: Message = {
            id: Date.now().toString(),
            from: 'player',
            text: messageText,
            timestamp: new Date()
        }

        setConversations({
            ...conversations,
            [playerId]: [...(conversations[playerId] || []), message]
        })

        // Simulate system response
        setTimeout(() => {
            let responseText = ''
            const upperMessage = messageText.toUpperCase().trim()

            // Helper function to check if a player has said YES
            const hasPlayerSaidYes = (pId: string) => {
                const msgs = conversations[pId] || []
                return msgs.some(m => m.from === 'player' && m.text.toUpperCase() === 'YES')
            }

            // Count players who have ALREADY said YES (not including current message)
            const alreadyConfirmedPlayers = selectedPlayers.filter(p => hasPlayerSaidYes(p.player_id))
            const alreadyConfirmedCount = alreadyConfirmedPlayers.length

            if (upperMessage === 'YES') {
                // Check if this player already said YES
                if (hasPlayerSaidYes(playerId)) {
                    responseText = 'âœ… You already confirmed! We\'ll notify you when we have 4 players.'
                } else if (alreadyConfirmedCount >= 4) {
                    // Match is already full (4 others already confirmed)
                    responseText = 'âŒ Sorry, this match is already full (4/4 players confirmed). We\'ll let you know about the next one!'
                } else if (alreadyConfirmedCount === 3) {
                    // This player makes it 4 - match is now confirmed!
                    responseText = 'âœ… Great! We have 4 players. Match is confirmed! ðŸŽ¾'
                } else {
                    // This player is confirming, show new count
                    const newCount = alreadyConfirmedCount + 1
                    responseText = `âœ… Thanks! You're interested. We'll notify you when we have 4 players. (${newCount}/4 confirmed)`
                }
            } else if (upperMessage === 'NO') {
                responseText = 'âŒ No problem, maybe next time!'
            } else if (['1', '2', '3'].includes(upperMessage)) {
                responseText = `âœ… Got it! You voted for option ${upperMessage}.`
            } else if (upperMessage === 'STATUS') {
                // Show who has confirmed
                const confirmedPlayers = selectedPlayers.filter(p => {
                    const msgs = conversations[p.player_id] || []
                    return msgs.some(m => m.from === 'player' && m.text.toUpperCase() === 'YES')
                })
                if (confirmedPlayers.length === 0) {
                    responseText = 'ðŸ“Š No players have confirmed yet.'
                } else {
                    const names = confirmedPlayers.map(p => `${p.name} (${p.declared_skill_level})`).join(', ')
                    responseText = `ðŸ“Š Confirmed players (${confirmedPlayers.length}/4): ${names}`
                }
            } else if (upperMessage === 'HELP' || upperMessage === '?') {
                // Show available commands
                responseText = `ðŸŽ¾ Padel Match Maker Commands:
â€¢ YES/NO - Respond to match invites
â€¢ STATUS - Check confirmed players
â€¢ MATCHES - View upcoming matches
â€¢ CANCEL - Cancel your participation
â€¢ 1/2/3 - Vote for time slots
â€¢ HELP - Show this message

Reply STOP to opt out.`
            } else if (upperMessage === 'MATCHES') {
                // Show upcoming matches (simplified - would query database in real system)
                const hasConfirmed = hasPlayerSaidYes(playerId)
                if (hasConfirmed) {
                    // Get all confirmed players
                    const confirmedPlayers = selectedPlayers.filter(p => hasPlayerSaidYes(p.player_id))
                    const confirmedCount = confirmedPlayers.length
                    const confirmedNames = confirmedPlayers.map(p => `${p.name} (${p.declared_skill_level})`).join(', ')

                    const matchStatus = confirmedCount >= 4 ? 'Confirmed âœ…' : `Pending (${confirmedCount}/4)`

                    responseText = `ðŸ“… Your upcoming matches:
â€¢ Tomorrow 3:00 PM - Court 2 (${matchStatus})
  Players: ${confirmedNames}

Reply STATUS for updates.`
                } else {
                    responseText = 'ðŸ“… You have no upcoming matches. Reply YES to join the current match invite!'
                }
            } else if (upperMessage === 'CANCEL') {
                // Cancel participation
                const hasConfirmed = hasPlayerSaidYes(playerId)
                if (hasConfirmed) {
                    // Remove all YES messages from this player's conversation
                    const updatedMessages = (conversations[playerId] || []).filter(
                        m => !(m.from === 'player' && m.text.toUpperCase() === 'YES')
                    )

                    // Update conversations state immediately
                    setConversations(prev => ({
                        ...prev,
                        [playerId]: updatedMessages
                    }))

                    responseText = 'âŒ You have been removed from the match. We\'ll notify the other players. Hope to see you at the next one!'
                    // In real system, would update database and notify other players
                } else {
                    responseText = 'âŒ You haven\'t confirmed any matches yet. Nothing to cancel!'
                }
            } else {
                responseText = 'I didn\'t understand that. Reply HELP for available commands.'
            }

            const systemMessage: Message = {
                id: Date.now().toString() + '-system',
                from: 'system',
                text: responseText,
                timestamp: new Date()
            }

            setConversations(prev => ({
                ...prev,
                [playerId]: [...(prev[playerId] || []), systemMessage]
            }))
        }, 500)
    }

    const handleReset = () => {
        if (confirm('Reset all conversations?')) {
            setConversations({})
            selectedPlayers.forEach(player => {
                setConversations(prev => ({
                    ...prev,
                    [player.player_id]: []
                }))
            })
        }
    }

    return (
        <div className="min-h-screen bg-gray-50 p-6">
            <div className="max-w-7xl mx-auto">
                {/* Header */}
                <div className="mb-6">
                    <h1 className="text-2xl font-bold text-gray-900 mb-2">SMS Testing Simulator</h1>
                    <p className="text-gray-600">Test SMS match flow with simulated player responses</p>
                </div>

                {/* Controls */}
                <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4 mb-6">
                    <div className="flex flex-wrap items-center gap-4">
                        <div className="flex items-center gap-2">
                            <label className="text-sm font-medium text-gray-700">Add Player:</label>
                            <select
                                onChange={(e) => handleSelectPlayer(e.target.value)}
                                value=""
                                className="px-3 py-1.5 border border-gray-300 rounded-md text-sm focus:ring-indigo-500 focus:border-indigo-500"
                                disabled={selectedPlayers.length >= 6}
                            >
                                <option value="">Select player...</option>
                                {players
                                    .filter(p => !selectedPlayers.find(sp => sp.player_id === p.player_id))
                                    .map(player => (
                                        <option key={player.player_id} value={player.player_id}>
                                            {player.name} - Level {player.declared_skill_level}
                                        </option>
                                    ))}
                            </select>
                            <span className="text-sm text-gray-500">
                                ({selectedPlayers.length}/6 selected)
                            </span>
                        </div>

                        <button
                            onClick={handleSendMatchInvite}
                            disabled={loading || selectedPlayers.length < 4}
                            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm font-medium"
                        >
                            Send Match Invites
                        </button>

                        <button
                            onClick={handleReset}
                            className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 text-sm font-medium"
                        >
                            Reset All
                        </button>
                    </div>
                </div>

                {/* Player Columns */}
                {selectedPlayers.length === 0 ? (
                    <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-12 text-center">
                        <p className="text-gray-500">Select at least 4 players to start testing</p>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" style={{ height: '600px' }}>
                        {selectedPlayers.map(player => (
                            <div key={player.player_id} className="relative">
                                <button
                                    onClick={() => handleRemovePlayer(player.player_id)}
                                    className="absolute -top-2 -right-2 z-10 w-6 h-6 bg-red-500 text-white rounded-full hover:bg-red-600 flex items-center justify-center text-xs"
                                >
                                    âœ•
                                </button>
                                <PlayerColumn
                                    player={player}
                                    messages={conversations[player.player_id] || []}
                                    onSendMessage={(msg) => handlePlayerMessage(player.player_id, msg)}
                                />
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    )
}
